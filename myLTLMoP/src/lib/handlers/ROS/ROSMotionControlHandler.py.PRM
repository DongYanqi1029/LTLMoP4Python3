#!/usr/bin/env python
"""
=======================================================
vectorController.py - Vector Addition Motion Controller
=======================================================

Uses the vector field algorithm developed by Stephen R. Lindemann to calculate a global velocity vector to take the robot from the current region to the next region, through a specified exit face.
"""

import handlers.ROS.__PRMControllerHelper as PRMControllerHelper
from numpy import *
from handlers.share.MotionControl.__is_inside import *
import time, math
import logging
from decimal import Decimal

import lib.handlers.handlerTemplates as handlerTemplates

class ROSMotionControlHandler(handlerTemplates.MotionControlHandler):
    def __init__(self, executor, shared_data):
        """
        PRM + DRL motion planning controller
        """

        # Get references to handlers we'll need to communicate with
        self.drive_handler = executor.hsub.getHandlerInstanceByType(handlerTemplates.DriveHandler)
        self.pose_handler = executor.hsub.getHandlerInstanceByType(handlerTemplates.PoseHandler)
        # print(self.drive_handler)
        # print(self.pose_handler)

        # Get information about regions
        self.rfi = executor.proj.rfi
        self.coordmap_map2lab = executor.hsub.coordmap_map2lab
        self.coordmap_lab2map = executor.hsub.coordmap_lab2map
        self.last_warning = 0

    def gotoRegion(self, current_reg, next_reg, last=False):
        """
        If ``last`` is True, we will move to the center of the destination region.

        Returns ``True`` if we've reached the destination region.
        """

        if current_reg == next_reg and not last:
            # No need to move!
            self.drive_handler.setVelocity(0, 0)  # So let's stop
            return True

        # Find our current configuration
        pose = self.pose_handler.getPose()

        # Check if Vicon has cut out
        # TODO: this should probably go in posehandler?
        if math.isnan(pose[2]):
            print("WARNING: No Vicon data! Pausing.")
            self.drive_handler.setVelocity(0, 0)  # So let's stop
            time.sleep(1)
            return False

        # implement PRM Algorithm to find a path
        current = list(map(Decimal, map([pose[0], pose[1]])))
        destination = self.rfi.regions[next_reg].getCenter()
        destination = list(map(Decimal, map(self.coordmap_map2lab, [destination.x, destination.y])))

        allObs = []
        for region in self.rfi.regions:
            if region.isObstacle is True:
                pointArray = [pt for pt in region.getPoints()]
                pointArray = map(self.coordmap_map2lab, pointArray)
                vertices = mat(pointArray).T
                vertices = matrix(list(vertices[0, 0])).transpose() # size: 2 * num_of_vertices
                numV = vertices.size/2
                for i in range(numV):
                    topLeft = list(map(Decimal, [vertices[0, i % numV], vertices[1, i % numV]]))
                    bottomRight = list(map(Decimal, [vertices[0, (i+1) % numV], vertices[1, (i+1) % numV]]))
                    obs = PRMControllerHelper.Obstacle(topLeft, bottomRight)
                    obs.printFullCords()
                    allObs.append(obs)

        prm = PRMControllerHelper.PRMController(2000, allObs, current, destination)
        # Initial random seed to try
        initialRandomSeed = 0
        path = prm.runPRM(initialRandomSeed)

        # TO DO
        V = setVelocityFromPath(path)

        # Pass this desired velocity on to the drive handler
        self.drive_handler.setVelocity(V[0], V[1], pose[2])

        pointArray = [x for x in self.rfi.regions[current_reg].getPoints()]
        pointArray = map(self.coordmap_map2lab, pointArray)
        vertices = mat(pointArray).T

        vertices = matrix(list(vertices[0, 0])).transpose()

        departed = not is_inside([pose[0], pose[1]], vertices)
        pointArray = [x for x in self.rfi.regions[next_reg].getPoints()]
        pointArray = map(self.coordmap_map2lab, pointArray)
        vertices = mat(pointArray).T

        vertices = matrix(list(vertices[0,0])).transpose()
        # logging.warning(vertices)

        # Figure out whether we've reached the destination region
        arrived = is_inside([pose[0], pose[1]], vertices)

        if departed and (not arrived) and (time.time()-self.last_warning) > 0.5:
            #print "WARNING: Left current region but not in expected destination region"
            # Figure out what region we think we stumbled into
            for r in self.rfi.regions:
                pointArray = [self.coordmap_map2lab(x) for x in r.getPoints()]
                vertices = mat(pointArray).T

                if is_inside([pose[0], pose[1]], vertices):
                    print("I think I'm in " + r.name)
                    print(pose)
                    break
            self.last_warning = time.time()

        return arrived
