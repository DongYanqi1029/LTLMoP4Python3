
#!/usr/bin/env python
"""
=================================================
rosSim.py - ROS/Gazebo Initialization Handler
=================================================
"""
import math
import roslib
# roslib.load_manifest('gazebo')
import sys, subprocess, os, time, os, shutil, rospy

# import gi
# gi.require_version('Rsvg', '2.0')
# from gi.repository import Rsvg

# import cairo

from svglib.svglib import svg2rlg
from reportlab.graphics import renderPM

import re, Polygon, Polygon.IO
import lib.regions as regions
#import execute
from numpy import *
#from gazebo.srv import *
from gazebo_msgs.srv import *
from gazebo_ros import gazebo_interface
from gazebo_msgs.msg import ModelState
from geometry_msgs.msg import Pose
from geometry_msgs.msg import Twist
import fileinput

import lib.handlers.handlerTemplates as handlerTemplates
import logging

from cheetah.Template import Template

class RosInitHandler(handlerTemplates.InitHandler):
    def __init__(self, executor, init_region, worldFile='ltlmop_map.world', robotPixelWidth=40, robotPhysicalWidth=.5, robotPackage="simulator_gazebo", robotLaunchFile="turtlebot3_burger.launch", modelName = "turtlebot3_burger"):
        """
        Initialization handler for ROS and gazebo

        init_region (region): The initial region of the robot
        worldFile (str): The alternate world launch file to be used (default="ltlmop_map.world")
        robotPixelWidth (int): The width of the robot in pixels in ltlmop (default=200)
        robotPhysicalWidth (float): The physical width of the robot in meters (default=.5)
        robotPackage (str): The package where the robot is located (default="pr2_gazebo")
        robotLaunchFile (str): The launch file name for the robot in the package (default="pr2.launch")
        modelName(str): Name of the robot. Choices: pr2 and quadrotor for now(default="pr2")
        """

        self.proj = executor.proj
        # Set a blank offset for moving the map
        self.offset=[0,0]
        # The package and launch file for the robot that is being used
        self.package = robotPackage
        self.launchFile = robotLaunchFile
        # The world file that is to be launched, see gazebo_worlds/worlds
        self.worldFile = worldFile
        # Map to real world scaling constant
        self.ratio = robotPhysicalWidth/robotPixelWidth
        self.robotPhysicalWidth = robotPhysicalWidth
        self.modelName = modelName
        self.coordmap_map2lab = executor.hsub.coordmap_map2lab
        addObstacle = False

        # change the starting pose of the box
        self.original_regions = self.proj.loadRegionFile()
        self.region_file_name = self.proj.spec_data['SETTINGS']['RegionFile'][0].rstrip('.regions')
        self.spec_file_name = self.proj.getFilenamePrefix().split('/')[-1]

        self.worldFile = self.region_file_name + "_region_map.world"
        self.mapPic = self.region_file_name + '_region_map.png'
        self.materialFile = self.region_file_name + '_region_map.material'

        self.destination = "/home/dongyanqi/catkin_ws/src/simulator_gazebo/worlds/" + self.worldFile

        # Center the robot in the init region (not on calibration)
        if init_region == "__origin__":
            os.environ['ROBOT_INITIAL_POSE'] = "-x " + str(0) + " -y " + str(0)
        else:
            self.centerTheRobot(executor, init_region)

        # Create world file
        self.worldNamespace = {}

        f = open('../templates/region_map.world.tmpl', 'r')
        worldDef = f.read()
        f.close()

        # Set world name
        worldName = self.region_file_name + '_world'
        self.worldNamespace['world_name'] = worldName

        # This creates a png copy of the regions to load into gazebo
        self.createRegionMap(executor.proj)
        # Add obstacle
        # self.addObstacles()
        # Create file
        f = open(self.destination)
        world = Template(worldDef, searchList=self.worldNamespace)
        f.write(world)
        f.close()

        # Change robot and world file in gazebo:
        self.changeRobotAndWorld()

        # set up a publisher to publish pose
        self.pub = rospy.Publisher('/gazebo/set_model_state', ModelState, queue_size=10)

        # Create a subprocess for ROS
        self.rosSubProcess(executor.proj)

        #The following is a global node for LTLMoP
        rospy.init_node('LTLMoPHandlers')

    def createRegionPolygon(self, region, hole=None):
        """
        This function takes in the region points and make it a Polygon.
        """
        if hole is None:
            pointArray = [x for x in region.getPoints()]
        else:
            pointArray = [x for x in region.getPoints(hole_id = hole)]
        pointArray = map(self.coordmap_map2lab, pointArray)
        regionPoints = [(pt[0],pt[1]) for pt in pointArray]
        formedPolygon= Polygon.Polygon(regionPoints)
        return formedPolygon

    def addBox(self, i, length, depth, height, pose):
        """
        to add a box into the world
        i = count for the name  (just to distinguish one model from another)
        length = length of the box (in x direction)
        depth  = depth of the box  (in y direction)
        height = height of the cylinder
        pose   = center of the cylinder
        """
        # for editing the starting pose of the box

        path="/home/dongyanqi/catkin_ws/src/simulator_gazebo/worlds/ltlmop_box.world"
        # change the name of the model/link/collision/visual
        searchExp='<model name='
        replaceExp='    <model name="Box_' + str(i) + '_Model">\n'
        self.replaceAll(path, searchExp, replaceExp)
        searchExp = '<link name='
        replaceExp = '      <link name="Box_' + str(i) + '">\n'
        self.replaceAll(path, searchExp, replaceExp)
        searchExp = '<collision name='
        replaceExp = '        <collision name="Box_' + str(i) + '_Collision">\n'
        self.replaceAll(path, searchExp, replaceExp)
        searchExp = '<visual name='
        replaceExp = '        <visual name="Box_' + str(i) + '_Visual">\n'
        self.replaceAll(path, searchExp, replaceExp)

        # position of the collision/visual
        searchExp = '<collision name='
        replaceExp = '          <pose>0.000000 0.000000 '+str(float(height)/2)+' 0 -0.000000 0.000000</pose>\n'
        self.replaceNextLine(path, searchExp, replaceExp)
        searchExp = '<visual name='
        replaceExp = '          <pose>0.000000 0.000000 '+str(float(height)/2)+' 0 -0.000000 0.000000</pose>\n'
        self.replaceNextLine(path, searchExp, replaceExp)

        # change the pose of the model/link
        searchExp = '<model name='
        replaceExp = '      <pose>' + str(pose[0]) + ' ' + str(pose[1]) + ' 0 0 0 0</pose>\n'
        self.replaceNextLine(path, searchExp, replaceExp)
        searchExp = '<link name='
        replaceExp = '        <pose>0 0 0 0 0 0</pose>\n'
        self.replaceNextLine(path, searchExp, replaceExp)

        # change the radius and height of the model
        searchExp='<box>'
        replaceExp='              <size>' + str(length) + ' ' + str(depth) + ' ' + str(height) + '</size>\n'
        self.replaceNextLine(path, searchExp, replaceExp)

        #append to the world file
        self.appendObject(path, self.destination)

        # change the state file for cylinder
        path="/home/dongyanqi/catkin_ws/src/simulator_gazebo/worlds/ltlmop_state_box.world"
        searchExp='<model name='
        replaceExp='      <model name="Box_' + str(i) + '_Model">\n'
        self.replaceAll(path, searchExp, replaceExp)
        searchExp = '<link name='
        replaceExp = '        <link name="Box_' + str(i) + '">\n'
        self.replaceAll(path, searchExp, replaceExp)

        searchExp = '<model name='
        replaceExp = '        <pose>'+str(pose[0])+' '+str(pose[1])+' 0 0 0 0 </pose>\n'
        self.replaceNextLine(path, searchExp, replaceExp)
        searchExp='<link name='
        replaceExp='          <pose>0 0 0 0 0 0</pose>\n'
        self.replaceNextLine(path, searchExp, replaceExp)

        #append to the state file
        self.appendObject(path, self.state)

    def addCylinder(self,i,radius, height, pose):
        """
        to add a cylinder into the world
        i = count for the name  (just to distinguish one model from another)
        radius = radius of the cylinder
        height = height of the cylinder
        pose   = center of the cylinder
        """
        # for editing the starting pose of the cylinder (box works the same way)
        # for editing the starting pose of the box

        path = "/home/dongyanqi/catkin_ws/src/simulator_gazebo/worlds/ltlmop_cylinder.world"
        # change the name of the model/link/collision/visual
        searchExp = '<model name='
        replaceExp = '    <model name="Cylinder_' + str(i) + '_Model">\n'
        self.replaceAll(path, searchExp, replaceExp)
        searchExp = '<link name='
        replaceExp = '      <link name="Cylinder_' + str(i) + '">\n'
        self.replaceAll(path, searchExp, replaceExp)
        searchExp = '<collision name='
        replaceExp = '        <collision name="Cylinder_' + str(i) + '_Collision">\n'
        self.replaceAll(path, searchExp, replaceExp)
        searchExp = '<visual name='
        replaceExp = '        <visual name="Cylinder_' + str(i) + '_Visual">\n'
        self.replaceAll(path, searchExp, replaceExp)

        # position of the collision/visual
        searchExp = '<collision name='
        replaceExp = '          <pose>0.000000 0.000000 ' + str(float(height) / 2) + ' 0 -0.000000 0.000000</pose>\n'
        self.replaceNextLine(path, searchExp, replaceExp)
        searchExp = '<visual name='
        replaceExp = '          <pose>0.000000 0.000000 ' + str(float(height) / 2) + ' 0 -0.000000 0.000000</pose>\n'
        self.replaceNextLine(path, searchExp, replaceExp)

        # change the pose of the model/link
        searchExp = '<model name='
        replaceExp = '      <pose>' + str(pose[0]) + ' ' + str(pose[1]) + ' 0 0 0 0</pose>\n'
        self.replaceNextLine(path, searchExp, replaceExp)
        searchExp = '<link name='
        replaceExp = '        <pose>0 0 0 0 0 0</pose>\n'
        self.replaceNextLine(path, searchExp, replaceExp)

        # change the radius and height of the model
        searchExp = '<cylinder>'
        replaceExp = '              <size>' + str(radius) + ' ' + str(height) + '</size>\n'
        self.replaceNextLine(path, searchExp, replaceExp)

        # append to the world file
        self.appendObject(path, self.destination)

        # change the state file for cylinder
        path = "/home/dongyanqi/catkin_ws/src/simulator_gazebo/worlds/ltlmop_state_cylinder.world"
        searchExp = '<model name='
        replaceExp = '      <model name="Cylinder_' + str(i) + '_Model">\n'
        self.replaceAll(path, searchExp, replaceExp)
        searchExp = '<link name='
        replaceExp = '        <link name="Cylinder_' + str(i) + '">\n'
        self.replaceAll(path, searchExp, replaceExp)

        searchExp = '<model name='
        replaceExp = '        <pose>' + str(pose[0]) + ' ' + str(pose[1]) + ' 0 0 0 0 </pose>\n'
        self.replaceNextLine(path, searchExp, replaceExp)
        searchExp = '<link name='
        replaceExp = '          <pose>0 0 0 0 0 0</pose>\n'
        self.replaceNextLine(path, searchExp, replaceExp)

        # append to the state file
        self.appendObject(path, self.state)

    def replaceNextLine(self,file,searchExp,replaceExp):
        """
        Relaces lines in a file given a search string and replacement string
        You only need a portion of the line to match the searchExp and
        then it will replace the whole line with the replaceExp
        """
        found = False
        done  = False
        for line in fileinput.input(file, inplace=1):

            if found is True:
                done = True
                found = False
                #print line
                #print "replace"
                line = line.replace(line,replaceExp)

            if searchExp in line and done is False:
                found = True

            sys.stdout.write(line)

    def appendObject(self,source, dest):
        """
        append lines from source file to destination file
        source: source file
        dest  : destination file
        """
        myfile = open(source,"r")
        #with open(source,"r") as myfile:
        f=open(dest,"a") ## file open in appending mode i.e 'a'
        for line in myfile:
            f.write(line)
        f.close() ## File closing after writingself.
        myfile.close()

    def getSharedData(self):
        # TODO: Return a dictionary of any objects that will need to be shared with other handlers
        return {'ROS_INIT_HANDLER': self}

    def region2svg(self, proj, regionFile):
        """
        Converts region file to svg
        This is from the deprecated regions file with slight changes for
        proper calculation of the size of the regions map
        """
        fout = re.sub(r"\.region$", ".svg", regionFile)
        rfi = regions.RegionFileInterface()
        rfi.readFile(regionFile)

        polyList = []

        for region in rfi.regions:
            points = [(pt.x, -pt.y) for pt in region.getPoints()]
            poly = Polygon.Polygon(points)
            polyList.append(poly)
        try: # Normal Operation
            boundary = proj.rfiold.regions[proj.rfiold.indexOfRegionWithName("boundary")]
        except: # Calibration
            boundary = proj.rfi.regions[proj.rfi.indexOfRegionWithName("boundary")]
        width = boundary.size.width
        height = boundary.size.height

        # use boundary size for image size
        # Polygon.IO.writeSVG(fout, polyList,width=width,height=height)
        Polygon.IO.writeSVG(fout, polyList, width=height, height=width)   # works better than width=width,height=height


        return fout  # return the file name

    def replaceAll(self, file, searchExp, replaceExp):
        """
        Relaces lines in a file given a search string and replacement string
        You only need a portion of the line to match the searchExp and
        then it will replace the whole line with the replaceExp
        """
        for line in fileinput.input(file, inplace=1):
            if searchExp in line:
                line = line.replace(line, replaceExp)
            sys.stdout.write(line)

    def createRegionMap(self, proj):
        """
        This function creates the ltlmop region map as a floor plan in the
        Gazebo Simulator.
        """
        # This block creates a copy and converts to svg
        texture_dir = '/home/dongyanqi/catkin_ws/src/simulator_gazebo/materials/textures' #potentially dangerous as pathd in ROS change with updates
        ltlmop_path = proj.getFilenamePrefix()
        regionsFile = ltlmop_path + "_copy.regions"
        shutil.copy(proj.rfi.filename, regionsFile)
        svgFile = self.region2svg(proj, regionsFile) # svg file name
        drawing = svg2rlg(svgFile)
        
        # This block converts the svg to png and applies naming conventions
        renderPM.drawToFile(drawing, ltlmop_path+"_simbg.png", fmt='PNG')
        ltlmop_map_path = ltlmop_path + "_simbg.png"
        shutil.copy(ltlmop_map_path, texture_dir)
        full_pic_path = texture_dir + "/" + proj.project_basename + "_simbg.png"
        texture_pic_path = texture_dir + "/" + self.mapPic
        shutil.copyfile(full_pic_path, texture_pic_path)

        # Create material file
        f = open('../template/region_map.material.tmpl', 'r')
        materialDef = f.read()
        f.close()

        materialNamespace = {'map_pic': self.mapPic}
        material = Template(materialDef, searchList=[materialNamespace])

        material_path = '/home/dongyanqi/catkin_ws/src/simulator_gazebo/materials/scripts/' + self.materialFile
        f = open(material_path)
        f.write(material)
        f.close()

        # Change size of region map in gazebo
        from PIL import Image
        img = Image.open(texture_dir + "/" + self.mapPic)
        self.imgWidth = img.width
        self.imgHeight = img.height
        img.close()

        # This is accomplished through edits of the world file before opening
        T = [self.ratio * self.imgWidth, self.ratio * self.imgHeight]
        resizeX = T[0]
        resizeY = T[1]

        self.worldNamespace['imgWidth'] = str(resizeX)
        self.worldNamespace['imgHeight'] = str(resizeY)
        self.worldNamespace['ground_plane_material_path'] = material_path



    def changeRobotAndWorld(self, proj):
        """
        This changes the robot in the launch file
        """
        # Accomplish through edits in the launch file
        path = "/home/dongyanqi/catkin_ws/src/simulator_gazebo/launch/simulation_launch/" + self.spec_file_name + "_world.launch"

        # Open launch file template
        f = open('templates/world.launch.tmpl')
        launchDef = f.read()
        launchNamespace = {}
        f.close()

        launchNamespace['robot_pkg'] = self.package
        launchNamespace['robot_launch'] = self.launchFile

        # change robot position
        pos_str = os.getenv('ROBOT_INITIAL_POSE')
        if not pos_str is None:

            pos_x = pos_str.split()[1]
            pos_y = pos_str.split()[3]
            # pos_x = str(1)
            # pos_y = str(0)

            launchNamespace['coord_x'] = pos_x
            launchNamespace['coord_y'] = pos_y

        # World file
        launchNamespace['world_file'] = self.worldFile

        # Create launch File
        launch = Template(launchDef, searchList=launchNamespace)
        f = open(path)
        f.write(launch)
        f.close()



    def addObstacles(self, proj):
        # check if there are obstacles. If so, they will be added to the world
        for region in self.original_regions.regions:
            if region.isObstacle is True:
                addObstacle = True
                break

        if addObstacle is False:
            print("INIT:NO obstacle")

        if addObstacle is True:
            print("INIT:OBSTACLES!!")
            # start the ltlmop_state.world file with the necessities

            i = 0
            ######### ADDED

            self.map = {'polygon': {}, 'original_name': {}, 'height': {}}
            for region in self.proj.rfi.regions:
                self.map['polygon'][region.name] = self.createRegionPolygon(region)
                for n in range(len(region.holeList)):  # no of holes
                    self.map['polygon'][region.name] -= self.createRegionPolygon(region, n)

            ###########
            for region in self.original_regions.regions:
                if region.isObstacle is True:
                    poly_region = self.createRegionPolygon(region)
                    center = poly_region.center()
                    print("center:" + str(center), file=sys.stdout)
                    pose = self.coordmap_map2lab(region.getCenter())
                    print("pose:" + str(pose), file=sys.stdout)
                    pose = center
                    height = region.height
                    if height == 0:
                        height = self.original_regions.getMaximumHeight()

                    a = poly_region.boundingBox()
                    size = [a[1] - a[0], a[3] - a[2]]  # xmax,xmin,ymax,ymin

                    if "pillar" in region.name.lower():  # cylinders
                        radius = min(size[0], size[1]) / 2
                        print("INIT: pose " + str(pose) + " height: " + str(height) + " radius: " + str(radius))
                        self.addCylinder(i, radius, height, pose)
                    else:
                        length = size[0]  # width in region.py = size[0]
                        depth = size[1]  # height in region.py =size[1]
                        print("INIT: pose " + str(pose) + " height: " + str(height) + " length: " + str(
                            length) + " depth: " + str(depth))
                        self.addBox(i, length, depth, height, pose)
                    i += 1


    def rosSubProcess(self, proj, worldFile='ltlmop_map.world'):
        start = subprocess.Popen(['roslaunch simulator_gazebo ltlmop_world.launch'], shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        start_output = start.stdout
        # logging.info(start_output.read())

        time.sleep(5)
        logging.info("Launch finished")

        # # Wait for it to fully start up
        # while 1:
        #     logging.info("Test")
        #     input = start_output.readline()
        #     logging.info("Test")
        #     print(type(input))
        #     logging.info("Get input: " + input)
        #     if input == '': # EOF
        #         print("(INIT) WARNING:  Gazebo seems to have died!")
        #         break
        #     if "Successfully spawned" or "successfully spawned" in input:
        #         # Successfully spawend is output from the creation of the PR2
        #         # It might get stuck waiting for another type of robot to spawn
        #         logging.info("Successfully spawned")
        #         time.sleep(5)
        #         break

    def centerTheRobot(self, executor, init_region):
        # Start in the center of the defined initial region

        try: #Normal operation
            initial_region = self.proj.rfiold.regions[self.proj.rfiold.indexOfRegionWithName(init_region)]
        except: #Calibration
            initial_region = self.proj.rfi.regions[self.proj.rfi.indexOfRegionWithName(init_region)]
        center = initial_region.getCenter()

        # Load the map calibration data and the region file data to feed to the simulator
        coordmap_map2lab, coordmap_lab2map = executor.hsub.getMainRobot().getCoordMaps()
        map2lab = list(coordmap_map2lab(array(center)))

        print("Initial region name: " + str(initial_region.name) + " I think I am here: " + str(map2lab) + " and center is: " + str(center))

        os.environ['ROBOT_INITIAL_POSE'] = "-x "+str(map2lab[0])+" -y "+str(map2lab[1])
        # os.environ['ROBOT_INITIAL_POSE'] = "-x " + str(0) + " -y " + str(0)
        # print((map2lab[0], map2lab[1]))
